#cloud-config

# Update package database on first boot (ie. run `apt-get update`)
package_update: true

# Upgrade installed packages on first boot (ie. run `apt-get upgrade`)
package_upgrade: true

apt:
  # Preserves the existing /etc/apt/sources.list
  preserve_sources_list: true

  # Add repositories
  sources:
    postgresql.list:
      source: "deb http://apt.postgresql.org/pub/repos/apt/ focal-pgdg main"
      keyid: 7FCC7D46ACCC4CF8

# We know that exactly one data disk will be attached to this VM and it will therefore use lun1 as lun0 is the OS disk
disk_setup:
  /dev/disk/azure/scsi1/lun1:
    table_type: gpt
    layout: true
    overwrite: true

fs_setup:
  - device: /dev/disk/azure/scsi1/lun1
    partition: 1
    filesystem: ext4

mounts:
  - [/dev/disk/azure/scsi1/lun1-part1, /data, ext4, "defaults,nofail"]

write_files:
  - path: "/etc/audit/rules.d/audit.rules"
    permissions: "0400"
    content: |
      {{audit.rules}}

  - path: "/etc/crontab"
    append: true
    content: |
      */10 * * * * postgres pg_ldap_sync -c /etc/postgresql/12/main/pg-ldap-sync.yaml -vv
      @reboot root /usr/local/bin/runonce | logger -t SafeHaven

  - path: "/etc/domain-join.secret"
    owner: root:root
    permissions: "0400"
    content: |
      {{{postgres.domainJoinPassword}}}

  - path: "/etc/krb5.conf"
    owner: root:root
    permissions: "0444"
    content: |
      {{krb5.mustache.conf}}

  - path: "/etc/ldap.secret"
    owner: root:root
    permissions: "0400"
    content: |
      {{{postgres.ldapSearchUserPassword}}}

  - path: "/etc/local/runonce.d/00-join-domain.sh"
    owner: root:root
    permissions: "0500"
    content: |
      #! /bin/bash
      echo ">=== Waiting for realm availability... ===<"
      while [ "$(realm discover {{shm.domain.fqdnLower}} 2> /dev/null | grep server-software | awk '{print $2}')" != "active-directory" ]; do sleep 1; done
      echo ">=== Joining domain '{{shm.domain.fqdnLower}}'... ===<"
      echo "/opt/configuration/join_domain.sh '{{shm.domain.fqdnLower}}' '{{shm.domain.ous.databaseServers.path}}' '{{shm.users.computerManagers.databaseServers.samAccountName}}' '{{postgres.vmName}}'"
      /opt/configuration/join_domain.sh "{{shm.domain.fqdnLower}}" "{{shm.domain.ous.databaseServers.path}}" "{{shm.users.computerManagers.databaseServers.samAccountName}}" "{{postgres.vmName}}"

  - path: "/etc/local/runonce.d/01-generate-keytab.sh"
    owner: root:root
    permissions: "0500"
    content: |
      #! /bin/bash
      # Generate a keytab and verify by getting a Kerberos ticket
      echo ">=== Generating service principal credentials... ===<"
      SERVICE_PRINCIPAL="POSTGRES/{{postgres.vmName}}.{{shm.domain.fqdnLower}}"
      KEYTAB_PATH="/var/lib/postgresql/data/postgres.keytab"
      install -g postgres -o postgres -d /var/lib/postgresql/data/ # create the directory with correct ownership
      echo "ldapsearch -b '{{postgres.ldapPostgresServiceAccountDn}}' -h {{shm.dc.hostnameUpper}}.{{shm.domain.fqdnLower}} -D '{{{postgres.ldapSearchUserDn}}}' -W msDS-KeyVersionNumber"
      KVNO=$(ldapsearch -b "{{postgres.ldapPostgresServiceAccountDn}}" -h {{shm.dc.hostnameUpper}}.{{shm.domain.fqdnLower}} -D "{{{postgres.ldapSearchUserDn}}}" -w $(cat /etc/ldap.secret) msDS-KeyVersionNumber | grep "msDS-KeyVersionNumber:" | cut -d' ' -f2)
      echo "Current KVNO is $KVNO"
      # Use the same encryption methods and ordering as ktpass on Windows. The Active Directory default is RC4-HMAC.
      # NB. Kerberos will preferentially choose AES-256, but Active Directory does not support it without configuration changes. We therefore do not include it in the keytab
      DESCRC="add_entry -password -p $SERVICE_PRINCIPAL -k $KVNO -e des-cbc-crc\n$(cat /etc/postgres-service-account.secret)"
      DESMD5="add_entry -password -p $SERVICE_PRINCIPAL -k $KVNO -e des-cbc-md5\n$(cat /etc/postgres-service-account.secret)"
      A4HMAC="add_entry -password -p $SERVICE_PRINCIPAL -k $KVNO -e arcfour-hmac\n$(cat /etc/postgres-service-account.secret)"
      AES128="add_entry -password -p $SERVICE_PRINCIPAL -k $KVNO -e aes128-cts-hmac-sha1-96\n$(cat /etc/postgres-service-account.secret)"
      printf "%b" "$DESCRC\n$DESMD5\n$A4HMAC\n$AES128\nwrite_kt $KEYTAB_PATH" | ktutil
      echo "" # for appropriate spacing after the ktutil command
      # Set correct permissions for the keytab file
      chown postgres:postgres $KEYTAB_PATH
      chmod 0400 $KEYTAB_PATH
      echo ">=== Testing credentials with kinit... ===<"
      echo "klist -e -t -k $KEYTAB_PATH"
      klist -e -t -k $KEYTAB_PATH
      echo "kinit -t $KEYTAB_PATH $SERVICE_PRINCIPAL"
      kinit -t $KEYTAB_PATH $SERVICE_PRINCIPAL
      klist
      # Set the appropriate keytab file
      sed -i "s|#krb_server_keyfile|krb_server_keyfile = '$KEYTAB_PATH'\n#krb_server_keyfile|g" /etc/postgresql/12/main/postgresql.conf
      grep krb_server_keyfile /etc/postgresql/12/main/postgresql.conf

  - path: "/etc/local/runonce.d/02-initial-ldap-sync.sh"
    owner: root:root
    permissions: "0500"
    content: |
      #! /bin/bash
      echo ">=== Ensuring that LDAP sync has run... ===<"
      sudo -i -u postgres pg_ldap_sync -c /etc/postgresql/12/main/pg-ldap-sync.yaml -vv 2>&1

  - path: "/etc/local/runonce.d/03-set-public-schema-permissions.sh"
    owner: root:root
    permissions: "0500"
    content: |
      #! /bin/bash
      # Set appropriate permissions on public schema
      # - Remove privileges from PUBLIC (everyone)
      # - Create the 'data' schema belonging to data-admins and grant read access to research users
      # - Grant all privileges on the 'public' schema to research users
      # - Grant superuser privileges to sysadmins
      echo ">=== Setting appropriate permissions on public schema... ===<"
      sudo -i -u postgres psql -f /opt/configuration/create-postgres-triggers.sql

  - path: "/etc/local/runonce.d/04-list-postgres-users.sh"
    owner: root:root
    permissions: "0500"
    content: |
      #! /bin/bash
      # Restart the postgresql service
      echo ">=== Restarting postgres... ===<"
      systemctl restart postgresql@12-main
      sleep 10
      systemctl status postgresql@12-main

      # Show postgres users and roles
      echo ">=== List postgres users and roles... ===<"
      echo "USERS:"
      sudo -i -u postgres psql -q -c "SELECT * FROM pg_user;"
      echo "ROLES:"
      sudo -i -u postgres psql -q -c "SELECT rolname, rolsuper, rolinherit, rolinherit, rolcreatedb, rolcanlogin, oid FROM pg_roles;"
      echo "SCHEMAS:"
      sudo -i -u postgres psql -q -c "SELECT schema_name FROM information_schema.schemata;"

  - path: "/etc/postgres-user.secret"
    owner: root:root
    permissions: "0600"
    content: |
      {{{postgres.dbAdminPassword}}}

  - path: "/etc/postgres-service-account.secret"
    owner: root:root
    permissions: "0600"
    content: |
      {{{postgres.dbServiceAccountPassword}}}

  - path: "/etc/realmd.conf"
    owner: root:root
    permissions: "0400"
    content: |
      {{realmd.mustache.conf}}

  - path: "/opt/configuration/check_dns.sh"
    permissions: "0500"
    content: |
      {{check_dns.sh}}

  - path: "/opt/configuration/check_hostname.sh"
    permissions: "0500"
    content: |
      {{check_hostname.sh}}

  - path: "/opt/configuration/check_ntp.sh"
    permissions: "0500"
    content: |
      {{check_ntp.sh}}

  - path: "/opt/configuration/create-postgres-triggers.sql"
    owner: root:root
    permissions: "0444"
    content: |
      /* Ensure that all members of '{{sre.domain.securityGroups.systemAdministrators.name}}' have superuser permissions */
      /* Triggering on all ddl_command_end will catch any: CREATE, ALTER, DROP, SECURITY LABEL, COMMENT, GRANT or REVOKE command */
      /* We require that CURRENT_USER has SUPERUSER permissions inside the function, otherwise the ALTER USER calls will fail*/
      CREATE OR REPLACE FUNCTION fn_sysadmin_permissions()
        RETURNS event_trigger
        LANGUAGE plpgsql
      AS $$
      DECLARE
        obj record;
      BEGIN
        IF EXISTS (SELECT usename FROM pg_user WHERE ((usename = CURRENT_USER) AND (usesuper='t'))) THEN
          FOR obj in SELECT * FROM pg_user WHERE ((usesuper='t' or usecreatedb='t') AND (usename!='postgres') AND NOT pg_has_role(usesysid, '{{sre.domain.securityGroups.systemAdministrators.name}}', 'member')) LOOP
            EXECUTE format('ALTER USER "%s" WITH NOCREATEDB NOCREATEROLE NOSUPERUSER;', obj.usename);
          END LOOP;
          FOR obj in SELECT * FROM pg_user WHERE (pg_has_role(usesysid, '{{sre.domain.securityGroups.systemAdministrators.name}}', 'member')) LOOP
            EXECUTE format('ALTER USER "%s" WITH CREATEDB CREATEROLE SUPERUSER;', obj.usename);
          END LOOP;
        END IF;
      END;
      $$;
      CREATE EVENT TRIGGER trg_sysadmin_permissions ON ddl_command_end EXECUTE FUNCTION fn_sysadmin_permissions();
      /* Restrict default privileges on public schema to '{{sre.domain.securityGroups.researchUsers.name}}' */
      REVOKE ALL PRIVILEGES ON SCHEMA public FROM PUBLIC;
      GRANT ALL PRIVILEGES ON SCHEMA public TO "{{sre.domain.securityGroups.researchUsers.name}}";
      /* Add a trigger so that new tables under 'public' schema are readable by '{{sre.domain.securityGroups.researchUsers.name}}' */
      CREATE OR REPLACE FUNCTION fn_public_schema_table_permissions()
        RETURNS event_trigger
        LANGUAGE plpgsql
      AS $$
      DECLARE
        obj record;
      BEGIN
        FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands() WHERE (command_tag='CREATE TABLE' AND schema_name='public') LOOP
          EXECUTE format('GRANT SELECT ON TABLE %s TO "{{sre.domain.securityGroups.researchUsers.name}}";', obj.object_identity);
        END LOOP;
      END;
      $$;
      CREATE EVENT TRIGGER trg_public_schema_table_permissions ON ddl_command_end WHEN tag IN ('CREATE TABLE') EXECUTE PROCEDURE fn_public_schema_table_permissions();
      /* Create the data schema: allow '{{sre.domain.securityGroups.researchUsers.name}}' to read and '{{sre.domain.securityGroups.dataAdministrators.name}}' to do anything */
      CREATE SCHEMA IF NOT EXISTS data AUTHORIZATION "{{sre.domain.securityGroups.dataAdministrators.name}}";
      GRANT ALL PRIVILEGES ON SCHEMA data TO "{{sre.domain.securityGroups.dataAdministrators.name}}";
      GRANT USAGE ON SCHEMA data TO "{{sre.domain.securityGroups.researchUsers.name}}";
      /* Add a trigger so that new tables under 'data' schema are owned by '{{sre.domain.securityGroups.dataAdministrators.name}}' and readable by '{{sre.domain.securityGroups.researchUsers.name}}' */
      CREATE OR REPLACE FUNCTION fn_data_schema_table_permissions()
        RETURNS event_trigger
        LANGUAGE plpgsql
      AS $$
      DECLARE
        obj record;
      BEGIN
        FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands() WHERE (command_tag='CREATE TABLE' AND schema_name='data') LOOP
          EXECUTE format('ALTER TABLE %s OWNER TO "{{sre.domain.securityGroups.dataAdministrators.name}}"; GRANT SELECT ON TABLE %s TO "{{sre.domain.securityGroups.researchUsers.name}}";', obj.object_identity, obj.object_identity);
        END LOOP;
      END;
      $$;
      CREATE EVENT TRIGGER trg_data_schema_table_permissions ON ddl_command_end WHEN tag IN ('CREATE TABLE') EXECUTE PROCEDURE fn_data_schema_table_permissions();

  - path: "/opt/configuration/install-postgres-extensions.sql"
    owner: root:root
    permissions: "0444"
    content: |
      CREATE SCHEMA IF NOT EXISTS postgis;
      CREATE EXTENSION IF NOT EXISTS postgis;
      CREATE EXTENSION IF NOT EXISTS postgis_topology;
      CREATE EXTENSION IF NOT EXISTS postgis_sfcgal;
      CREATE EXTENSION IF NOT EXISTS pgrouting;
      CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
      CREATE EXTENSION IF NOT EXISTS unaccent;
      CREATE EXTENSION IF NOT EXISTS pg_trgm;
      CREATE EXTENSION IF NOT EXISTS bloom;
      CREATE EXTENSION IF NOT EXISTS citext;
      CREATE EXTENSION IF NOT EXISTS cube;
      CREATE EXTENSION IF NOT EXISTS file_fdw;
      CREATE EXTENSION IF NOT EXISTS postgres_fdw;
      CREATE EXTENSION IF NOT EXISTS earthdistance;

  - path: "/opt/configuration/join_domain.sh"
    owner: root:root
    permissions: "0500"
    content: |
      {{join_domain.sh}}

  - path: "/opt/configuration/pg-ldap-sync.yaml"
    owner: root:root
    permissions: "0700"
    content: |
      # LDAP-synchronized groups/users are identified through their
      # membership of ldap_user and ldap_group. These two roles must
      # therefore be manually defined before running pg_ldap_sync.

      # Connection parameters to LDAP server
      # see also: http://net-ldap.rubyforge.org/Net/LDAP.html#method-c-new
      # TODO: get SSL working on port 636
      ldap_connection:
        host: {{shm.dc.hostname}}
        #port: 636
        port: 389
        auth:
          method: :simple
          username: {{{postgres.ldapSearchUserDn}}}
          password: {{{postgres.ldapSearchUserPassword}}}
        #encryption:
        #  method: :simple_tls

      # Search parameters for LDAP users which should be synchronized
      ldap_users:
        base: {{shm.domain.ous.researchUsers.path}}
        # LDAP filter defining which LDAP users should be synchronized
        filter: {{{postgres.ldapUserFilter}}}
        # this attribute is used as PG role name
        name_attribute: sAMAccountName
        # lowercase name for use as PG role name
        lowercase_name: false

      # Search parameters for LDAP groups which should be synchronized
      ldap_groups:
        base: {{shm.domain.ous.securityGroups.path}}
        # LDAP filter defining which LDAP groups should be synchronized
        filter: {{{postgres.ldapGroupFilter}}}
        # this attribute is used as PG role name
        name_attribute: cn
        # lowercase name for use as PG role name
        lowercase_name: false
        # this attribute must reference to all member DN's of the given group
        member_attribute: member

      # Connection parameters to PostgreSQL server
      # see also: http://rubydoc.info/gems/pg/PG/Connection#initialize-instance_method
      pg_connection:
        host:
        dbname: postgres
        user: postgres
        password:

      pg_users:
        # Filter for identifying LDAP generated users in the database.
        # It's the WHERE-condition to "SELECT rolname, oid FROM pg_roles"
        filter: oid IN (SELECT pam.member FROM pg_auth_members pam JOIN pg_roles pr ON pr.oid=pam.roleid WHERE pr.rolname='ldap_users')
        # Options for CREATE RULE statements
        create_options: LOGIN IN ROLE ldap_users

      pg_groups:
        # Filter for identifying LDAP generated groups in the database.
        # It's the WHERE-condition to "SELECT rolname, oid FROM pg_roles"
        filter: oid IN (SELECT pam.member FROM pg_auth_members pam JOIN pg_roles pr ON pr.oid=pam.roleid WHERE pr.rolname='ldap_groups')
        # Options for CREATE RULE statements
        create_options: NOLOGIN IN ROLE ldap_groups
        grant_options:

  - path: "/usr/local/bin/runonce"
    owner: root:root
    permissions: "0500"
    content: |
      {{runonce.sh}}

# List of packages to install with apt-get
packages:
  - adcli
  - auditd
  - gcc
  - krb5-user
  - ldap-utils
  - libpq-dev
  - make
  - postgresql-12
  - postgresql-12-pgrouting
  - postgresql-12-postgis-3-scripts
  - postgresql-contrib-12
  - realmd
  - ruby
  - ruby-dev
  - sssd

# Set locale and timezone
locale: en_GB.UTF-8
timezone: {{sre.time.timezone.linux}}

# Set the NTP server
# By default we use Google's NTP servers which are incompatible with other servers due to leap-second smearing
ntp:
  enabled: true
  pools:
    {{#shm.time.ntp.serverAddresses}}
    - {{.}}
    {{/shm.time.ntp.serverAddresses}}


# Set hostname
# We need the FQDN in the hostname as without it we cannot set service principals when joining the Windows domain
fqdn: "{{postgres.vmName}}.{{shm.domain.fqdnLower}}"
hostname: {{postgres.vmName}}
manage_etc_hosts: true
prefer_fqdn_over_hostname: true

runcmd:
  # Ensure that auditd is running and enabled at startup
  - echo ">=== Enabling auditd services... ===<"
  - systemctl start auditd
  - systemctl enable auditd

  # Configure services for realm joining
  - echo ">=== Configuring domain joining settings... ===<"
  - OSVERSION=$(lsb_release -a 2> /dev/null | grep "Description:" | awk '{print $3}')
  - sed -i -E "s|(os-version = ).*|\1$OSVERSION|" /etc/realmd.conf
  # Check DNS
  - echo "Checking DNS..."
  - /opt/configuration/check_dns.sh
  # Check hostname
  - echo "Checking hostname..."
  - /opt/configuration/check_hostname.sh
  - systemctl enable sssd
  # Check Kerberos settings
  - echo "Checking Kerberos config"
  - grep -v -e '^[[:space:]]*$' /etc/krb5.conf | sed 's|^| /etc/krb5.conf |'
  # Check timezone and NTP server
  - echo "Current time synchronisation status..."
  - /opt/configuration/check_ntp.sh

  # Configure the postgres database
  - echo ">=== Configure postgres database... ===<"
  # Change the password for the postgres user
  - sudo -i -u postgres psql -tc "ALTER USER postgres WITH PASSWORD '$(cat /etc/postgres-user.secret)';"
  # Use external disk for storing data
  - systemctl stop postgresql@12-main
  - mkdir -p /data/postgresql
  - chmod 0700 /data/postgresql
  - chown -R postgres:postgres /data/
  - mv /var/lib/postgresql/12/main/* /data/postgresql
  - sed -i "s|data_directory = .*|data_directory = '/data/postgresql'|g" /etc/postgresql/12/main/postgresql.conf
  - grep data_directory /etc/postgresql/12/main/postgresql.conf
  # Allow login to this database from other VMs
  - sed -i "s|#listen_addresses|listen_addresses = '*'\n#listen_addresses|g" /etc/postgresql/12/main/postgresql.conf
  - grep listen_addresses /etc/postgresql/12/main/postgresql.conf
  # Restart the server with all the above changes
  - systemctl start postgresql@12-main
  - systemctl status postgresql@12-main

  # Create the required LDAP groups on the postgres server
  - echo ">=== Creating necessary LDAP roles... ===<"
  - |
    for ROLE in "ldap_users" "ldap_groups"; do
        ROLE_EXISTS=$(sudo -i -u postgres psql -tc "SELECT 1 FROM pg_roles WHERE rolname='${ROLE}'" | grep 1)
        if [ "$ROLE_EXISTS" = "" ]; then
            echo "Creating ${ROLE} role"
            sudo -i -u postgres psql -q -c "CREATE ROLE ${ROLE};"
        else
            echo "${ROLE} role already exists"
        fi
    done

  # Install postgres extensions
  - echo ">=== Installing postgis schema and extensions... ===<"
  - sudo -i -u postgres psql -f /opt/configuration/install-postgres-extensions.sql

  # Install pg-ldap-sync for adding LDAP users
  - echo ">=== Configuring pg-ldap-sync... ===<"
  # Add users
  - echo "Adding LDAP users with pg-ldap-sync..."
  - gem install pg-ldap-sync
  - mv /opt/configuration/pg-ldap-sync.yaml /etc/postgresql/12/main/pg-ldap-sync.yaml
  - chown postgres:postgres /etc/postgresql/12/main/pg-ldap-sync.yaml
  # Add cronjob
  - echo "Checking that LDAP user sync is scheduled every 10 minutes..."
  - grep pg_ldap_sync /etc/crontab

  # Allow Kerberos login - disable all other login types except the dbadmin on localhost
  - echo ">=== Restricting login types... ===<"
  - echo "local all postgres peer\nhost all all {{sre.network.vnet.subnets.compute.cidr}} gss include_realm=0 krb_realm={{shm.domain.fqdnUpper}}" > /etc/postgresql/12/main/pg_hba.conf
  - cat /etc/postgresql/12/main/pg_hba.conf

final_message: "System setup through cloud-init is finished. Configuration took $UPTIME seconds"

# Shutdown so that we can tell when the job has finished by polling the VM state
power_state:
  mode: poweroff
  message: "Shutting down as a signal that setup is finished"
  timeout: 30
  condition: true
