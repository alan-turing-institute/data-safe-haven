#cloud-config
package_update: true
package_upgrade: true

# Install LDAP tools for debugging LDAP issues
packages:
  - git
  - apt-transport-https
  - ca-certificates
  - curl
  - gitlab-ce
  - gnupg
  - ldap-utils
  - openssh-server
  - postfix

apt:
  # Preserves the existing /etc/apt/sources.list
  preserve_sources_list: true

  # Add repositories
  sources:
    gitlab.list:
      source: "deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu bionic main"
      keyid: 3F01618A51312F3F

write_files:
  # Gitlab server config
  - path: /etc/gitlab/gitlab.rb
    permissions: "0600"
    content: |
      external_url 'http://<gitlab-external-ip>'
      gitlab_rails['ldap_enabled'] = true
      gitlab_rails['ldap_servers'] = YAML.load <<-'EOS'
        main: # 'main' is the GitLab 'provider ID' of this LDAP server
          label: 'LDAP'
          host: '<gitlab-external-rb-host>'
          port: 389
          uid: 'sAMAccountName'
          method: 'plain' # "tls" or "ssl" or "plain"
          bind_dn: '<gitlab-external-rb-bind-dn>'
          password: '<gitlab-external-rb-pw>'
          active_directory: true
          allow_username_or_email_login: true
          block_auto_created_users: false
          base: '<gitlab-external-rb-base>'
          user_filter: '<gitlab-external-rb-user-filter>'
      attributes:
        username: ['uid', 'userid', 'sAMAccountName']
        email:    ['mail', 'email', 'userPrincipalName']
        name:       'cn'
        first_name: 'givenName'
        last_name:  'sn'
      EOS
      git_data_dirs({ "default" => { "path" => "/datadrive/gitdata" } })
  # Secrets for Gitlab Internal and External Access
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-api-token"
    permissions: "0600"
    content: |
      <gitlab-internal-api-token>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-ip-address"
    permissions: "0600"
    content: |
      <gitlab-internal-ip>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-username"
    permissions: "0600"
    content: |
      <gitlab-internal-username>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-user-email"
    permissions: "0600"
    content: |
      <gitlab-internal-username>@<gitlab-internal-login-domain>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-api-token"
    permissions: "0600"
    content: |
      <gitlab-external-api-token>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-ip-address"
    permissions: "0600"
    content: |
      <gitlab-external-ip>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-username"
    permissions: "0600"
    content: |
      <gitlab-external-username>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-user-email"
    permissions: "0600"
    content: |
      <gitlab-external-username>@<gitlab-external-login-domain>
  # Script for ingressing repos to gitlab internal
  - path: "/home/<sre-admin-username>/update_from_whitelist.py"
    permissions: "0755"
    content: |
      import os
      import json
      import requests
      import subprocess
      from pathlib import Path
      
      home = str(Path.home())
      
      with open("../whitelist", "r") as f:
          whitelist = [line.strip().split(" ") for line in f.readlines()]
      
      whitelist = [{"url": repo[0],
                    "commit_sha": repo[1],
                    "gitlab_name": repo[2],
                    "gitlab_branch": repo[3]} for repo in whitelist]
      
      with open(f"{home}/.secrets/gitlab-internal-ip-address","r") as f:
          gitlab_internal_ip = f.readlines()[0].strip()
      
      with open(f"{home}/.secrets/gitlab-internal-api-token","r") as f:
          gitlab_token = f.readlines()[0].strip()
      
      gitlab_internal_url = "http://" + gitlab_internal_ip + "/api/v4/projects"
      
      gitlab_internal_projects = requests.get(gitlab_internal_url,
                                              headers = {"Authorization": "Bearer " + gitlab_token},
                                              params = {"owned": True, "simple": True})
      
      gitlab_internal_repo_names = [repo["name"].lower() for repo in gitlab_internal_projects.json()]

      for repo in whitelist:
          repo_name = repo["gitlab_name"]
          repo_path = os.path.join(repo_name)
          if not os.path.exists(repo_path):
              os.system("git clone " + repo["url"] + " " + repo["gitlab_name"])
      
          os.chdir(repo["gitlab_name"])
          os.system("git fetch")
          os.system("git checkout " + repo["commit_sha"])
          os.system("git branch -f " + repo["gitlab_branch"])
          os.system("git checkout " + repo["gitlab_branch"])
      
          if repo_name.lower() not in gitlab_internal_repo_names:
              response = requests.post(gitlab_internal_url,
                                       headers = {"Authorization": "Bearer " + gitlab_token},
                                       data = {"name": repo_name, "visibility": "public"})
      
              gitlab_internal_remote_url = response.json()["ssh_url_to_repo"]
              assert(response.json()["name"] == repo_name)
      
              print("Adding remote gitlab-internal as " + gitlab_internal_remote_url)
              os.system("git remote add gitlab-internal " + gitlab_internal_remote_url)
      
          
          os.system("git push gitlab-internal " + repo["gitlab_branch"])
              
          os.chdir("..")
  # Script for monitoring and accepting approved merge requests
  - path: "/home/<sre-admin-username>/check_merge_requests.py"
    permissions: "0755"
    content: |
      from datetime import datetime
      import requests
      from pathlib import Path

      def get_request(endpoint, headers, params=None):
          if params is not None:
              r = requests.get(endpoint, headers=headers, params=params)
          else:
              r = requests.get(endpoint, headers=headers)
          if r.ok:
              return r.json()
          else:
              raise ValueError(f"Request failed: code {r.status_code}, content {r.content}")

      def put_request(endpoint, headers, params=None):
          if params is not None:
              r = requests.put(endpoint, headers=headers, params=params)
          else:
              r = requests.put(endpoint, headers=headers)
          if r.ok:
              return r.json()
          else:
              raise ValueError(f"Request failed: code {r.status_code}, content {r.content}")

      def get_gitlab_config(server="external"):
          home = str(Path.home())
          if server == "external":
              with open(f"{home}/.secrets/gitlab-external-ip-address", "r") as f:
                 ip = f.readlines()[0].strip()
              with open(f"{home}/.secrets/gitlab-external-api-token", "r") as f:
                 token = f.readlines()[0].strip()
          elif server == "internal":
              with open(f"{home}/.secrets/gitlab-internal-ip-address", "r") as f:
                  ip = f.readlines()[0].strip()
              with open(f"{home}/.secrets/gitlab-internal-api-token", "r") as f:
                  token = f.readlines()[0].strip()
          else:
              raise ValueError("Server must be external or internal")
          api_url = f"http://{ip}/api/v4/"
          headers = {"Authorization": "Bearer " + token}
          return {"api_url": api_url, "api_token": token, "ip": ip, "headers": headers}

      def get_group_id(group_name, config):
          endpoint = config["api_url"] + "groups"
          response = get_request(endpoint, headers=config["headers"])
          for group in response:
              if group["name"] == group_name:
                  return group["id"]
          raise ValueError(f"{group_name} not found in groups.")

      def get_project_name(project_id, config):
          endpoint = config["api_url"] + f"projects/{project_id}"
          response = get_request(endpoint, headers=config["headers"])
          return response["name"]

      def get_merge_requests_for_approval(config):
          group = get_group_id("approved", config)
          endpoint = config["api_url"] + f"/groups/{group}/merge_requests"
          response = get_request(
              endpoint, headers=config["headers"], params={"state": "opened"}
          )
          return response

      def count_unresolved_mr_discussions(mr, config):
          if mr["user_notes_count"] == 0:
              return 0
          project_id = mr["project_id"]
          mr_iid = mr["iid"]
          endpoint = (
              config["api_url"] + f"projects/{project_id}/merge_requests/{mr_iid}/discussions"
          )
          discussions = get_request(endpoint, headers=config["headers"])
          if len(discussions) == 0:
              return 0
          else:
              n_unresolved = 0
              for d in discussions:
                  for n in d["notes"]:
                      if n["resolvable"] is True and n["resolved"] is False:
                          n_unresolved += 1
              return n_unresolved

      def accept_merge_request(mr, config):
          project_id = mr["project_id"]
          mr_iid = mr["iid"]
          endpoint = (
              config["api_url"] + f"projects/{project_id}/merge_requests/{mr_iid}/merge"
          )
          result = put_request(endpoint, headers=config["headers"])
          return result

      def check_merge_requests():
          print("Starting run at", datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
          config = get_gitlab_config(server="external")
          print("Getting open merge requests for approval")
          merge_requests = get_merge_requests_for_approval(config)
          print("Found", len(merge_requests), "open merge requests")
          for i, mr in enumerate(merge_requests):
              print("-" * 20)
              print("Merge request", i, "out of", len(merge_requests))
              print("-" * 20)
              print("Project:", get_project_name(mr["project_id"], config))
              print("Source Branch:", mr["source_branch"])
              print("Target Branch:", mr["target_branch"])
              status = mr["merge_status"]
              print("Merge Status:", status)
              wip = mr["work_in_progress"]
              print("Work in Progress:", wip)
              unresolved = count_unresolved_mr_discussions(mr, config)
              print("Unresolved Discussions:", unresolved)
              upvotes = mr["upvotes"]
              print("Upvotes:", upvotes)
              downvotes = mr["downvotes"]
              print("Downvotes:", downvotes)
              if (
                  status == "can_be_merged"
                  and wip is False
                  and unresolved == 0
                  and upvotes >= 2
                  and downvotes == 0
              ):
                  print("Merge request has been approved. Proceeding with merge.")
                  result = accept_merge_request(mr, config)
                  if result["state"] == "merged":
                      print("Merge successful!")
                      # TODO CALL OLIVER'S FUNCTION
                  else:
                      print("Merge failed!")
              else:
                  print("Merge request has not been approved. Skipping.")
          print("-" * 20)
          print("Run finished at", datetime.now().strftime("%d/%m/%Y %H:%M:%S"))

      if __name__ == "__main__":
          check_merge_requests()

runcmd:
  # --------------------------------
  # SETUP GITLAB EXTERNAL SERVER
  # --------------------------------
  # Configure server
  - echo "Configuring gitlab external server"
  - echo "<gitlab-external-ip> <gitlab-external-hostname> <gitlab-external-fqdn>" >> /etc/hosts
  - echo "Europe/London" > /etc/timezone
  - dpkg-reconfigure -f noninteractive tzdata
  # Set up the data disk
  - echo "Setting up data disk..."
  - parted /dev/sdc mklabel gpt
  - parted /dev/sdc mkpart primary ext4 0% 100%
  - parted /dev/sdc print
  - sleep 5
  - mkfs -t ext4 /dev/sdc1
  - mkdir -p /datadrive
  - mount /dev/sdc1 /datadrive
  - UUID=$(blkid | grep "/dev/sdc1" | cut -d'"' -f2)
  - sed "s|UUID|UUID=$UUID\t/datadrive\text4\tdefaults,nofail\t1\t2\nUUID|" /etc/fstab > fstab.tmp
  - mv fstab.tmp /etc/fstab
  - mkdir -p /datadrive/gitlab-data
  # Enable custom GitLab settings and run an initial configuration
  - echo "Running initial configuration"
  - gitlab-ctl reconfigure
  # Set root password and don't prompt for it to be reset when web app first loaded
  - |
    echo "user = User.find_by(username: 'root');user.password=user.password_confirmation='<gitlab-external-root-password>';user.password_automatically_set=false;user.save!;exit;" | gitlab-rails console -e production
  # Turn off user account creation
  - |
    gitlab-rails runner "ApplicationSetting.last.update_attributes(signup_enabled: false)"
  # Restrict login to SHM domain (must be done AFTER GitLab update)
  - |
    gitlab-rails runner "ApplicationSetting.last.update_attributes(domain_whitelist: ['<gitlab-external-login-domain>'])"
  # Create user for ingressing external git repos
  - |
    echo "user = User.create(:username => '<gitlab-external-username>', :password => '<gitlab-external-password>', :password_confirmation => '<gitlab-external-password>', :email =>'<gitlab-external-username>@<gitlab-external-login-domain>', :skip_confirmation => true, :name => '<gitlab-external-username>');user.save!;exit;" | gitlab-rails console -e production
  # Create a API token for the ingress user created above
  - |
    echo "user = User.find_by(username: '<gitlab-external-username>');user.personal_access_tokens.create(name: 'apitoken', token_digest: Gitlab::CryptoHelper.sha256('<gitlab-external-api-token>'), impersonation: false, scopes: [:api]);exit;" | gitlab-rails console -e production
  # Reload GitLab configuration and restart GitLab
  - gitlab-ctl reconfigure
  - gitlab-ctl restart
  # --------------------------------
  # Create SSH key
  # --------------------------------
  - |
    mkdir -p /home/<sre-admin-username>/.ssh;
    ssh-keygen -t ed25519 -C 'gitlab' -N '' -f /home/<sre-admin-username>/.ssh/id_ed25519;
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/id_ed25519"
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/id_ed25519.pub"
  # --------------------------------
  # SETUP ACCESS TO GITLAB EXTERNAL
  # --------------------------------
  - echo "Configuring access to gitlab external"
  # Change ownership of secrets to <sre-admin-username>
  - |
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-api-token";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-ip-address";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-username";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-user-email";
  # Create SSH key for gitlab external access, add gitlab external to known hosts
  - |
    key=$(cat /home/<sre-admin-username>/.ssh/id_ed25519.pub);
    curl --header 'Authorization: Bearer <gitlab-external-api-token>' --header 'Content-Type:application/json' --data "{\"key\": \"$key\", \"title\": \"ExternalAPIUser\"}" <gitlab-external-ip>/api/v4/user/keys;
    ssh-keyscan -H <gitlab-external-ip> >> /home/<sre-admin-username>/.ssh/known_hosts;
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/known_hosts"
  # Create groups for storing unapproved and approved repos
  - |
    curl --header "Authorization: Bearer <gitlab-external-api-token>" --data "name=approved&path=approved&visibility=public" <gitlab-external-ip>/api/v4/groups;
    curl --header "Authorization: Bearer <gitlab-external-api-token>" --data "name=unapproved&path=unapproved&visibility=public" <gitlab-external-ip>/api/v4/groups
  # --------------------------------
  # SETUP ACCESS TO GITLAB INTERNAL
  # --------------------------------
  - echo "Configuring access to gitlab internal"
  # Change ownership of secrets to <sre-admin-username>
  - |
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-api-token";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-ip-address";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-username";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-user-email";
  # Create SSH key for gitlab internal access, add gitlab internal to known hosts
  - |
    key=$(cat /home/<sre-admin-username>/.ssh/id_ed25519.pub);
    curl --header 'Authorization: Bearer <gitlab-internal-api-token>' --header 'Content-Type:application/json' --data "{\"key\": \"$key\", \"title\": \"InternalAPIUser\"}" <gitlab-internal-ip>/api/v4/user/keys;
    ssh-keyscan -H <gitlab-internal-ip> >> /home/<sre-admin-username>/.ssh/known_hosts;
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/known_hosts"
  # --------------------------------
  # FINAL SETUP
  # --------------------------------
  - echo "Finishing setup"
  # Configure global git user to be gitlab internal user
  - |
    HOME=/home/<sre-admin-username> git config --global user.name '<gitlab-internal-username>';
    HOME=/home/<sre-admin-username> git config --global user.email '<gitlab-internal-username>@<gitlab-internal-login-domain>';
  # Give <sre-admin-username> ownership of their home directory
  - |
    chown -R <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>";

# Shutdown so that we can tell when the job has finished by polling the VM state
power_state:
  mode: poweroff
  message: "Shutting down as a signal that setup is finished"
  timeout: 30
  condition: true
