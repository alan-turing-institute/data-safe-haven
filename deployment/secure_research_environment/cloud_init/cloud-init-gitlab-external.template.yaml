#cloud-config
package_update: true
package_upgrade: true

# Install LDAP tools for debugging LDAP issues
packages:
  - git
  - apt-transport-https
  - ca-certificates
  - curl
  - gitlab-ce
  - gnupg
  - ldap-utils
  - openssh-server
  - postfix

apt:
  # Preserves the existing /etc/apt/sources.list
  preserve_sources_list: true

  # Add repositories
  sources:
    gitlab.list:
      source: "deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu bionic main"
      keyid: 3F01618A51312F3F

write_files:
  # Gitlab server config
  - path: /etc/gitlab/gitlab.rb
    permissions: "0600"
    content: |
      external_url 'http://<gitlab-external-ip>'
      gitlab_rails['ldap_enabled'] = true
      gitlab_rails['ldap_servers'] = YAML.load <<-'EOS'
        main: # 'main' is the GitLab 'provider ID' of this LDAP server
          label: 'LDAP'
          host: '<gitlab-external-rb-host>'
          port: 389
          uid: 'sAMAccountName'
          method: 'plain' # "tls" or "ssl" or "plain"
          bind_dn: '<gitlab-external-rb-bind-dn>'
          password: '<gitlab-external-rb-pw>'
          active_directory: true
          allow_username_or_email_login: true
          block_auto_created_users: false
          base: '<gitlab-external-rb-base>'
          user_filter: '<gitlab-external-rb-user-filter>'
      attributes:
        username: ['uid', 'userid', 'sAMAccountName']
        email:    ['mail', 'email', 'userPrincipalName']
        name:       'cn'
        first_name: 'givenName'
        last_name:  'sn'
      EOS
      git_data_dirs({ "default" => { "path" => "/datadrive/gitdata" } })
  # Secrets for Gitlab Internal and External Access
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-api-token"
    permissions: "0600"
    content: |
      <gitlab-internal-api-token>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-ip-address"
    permissions: "0600"
    content: |
      <gitlab-internal-ip>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-username"
    permissions: "0600"
    content: |
      <gitlab-internal-username>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-internal-user-email"
    permissions: "0600"
    content: |
      <gitlab-internal-username>@<gitlab-internal-login-domain>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-api-token"
    permissions: "0600"
    content: |
      <gitlab-external-api-token>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-ip-address"
    permissions: "0600"
    content: |
      <gitlab-external-ip>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-username"
    permissions: "0600"
    content: |
      <gitlab-external-username>
  - path: "/home/<sre-admin-username>/.secrets/gitlab-external-user-email"
    permissions: "0600"
    content: |
      <gitlab-external-username>@<gitlab-external-login-domain>
  # Script for creating projects and merge requests on gitlab-external
  - path: "/home/<sre-admin-username>/zipfile_to_gitlab_project.py"
    permissions: "0755"
    content: |
       import os
       import shutil
       import re
       import requests
       import subprocess
       from zipfile import ZipFile, BadZipFile
       from urllib.parse import quote as url_quote
       from pathlib import Path
       import logging
       from logging.handlers import RotatingFileHandler

       logger = logging.getLogger("project_upload_logger")
       logger.setLevel(logging.INFO)
       formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")
       f_handler = RotatingFileHandler(
       "upload_zipfiles_to_projects.log", maxBytes=5 * 1024 * 1024, backupCount=10
       )
       f_handler.setFormatter(formatter)
       c_handler = logging.StreamHandler()
       c_handler.setFormatter(formatter)
       logger.addHandler(f_handler)
       logger.addHandler(c_handler)


       def unzip_zipfiles(zipfile_dir, tmp_repo_dir):
           """
           Parameters
           ==========
           zipfile_dir: str, path to directory containing zipfiles
           tmp_repo_dir: str, path to directory where zipfiles will be unzipped

           Returns
           =======
           output_list: list of tuples
                  [(repo_name, commit_hash, desired_branch, unzipped-path),...]

           Note that the convention for the zipfile filenames is
           <repo-name>_<commit_hash>_<desired_branch_name>.zip
           """
           output_list = []
           repo_commit_regex = re.compile("([-\w]+)_([a-f\d]+)_([\S]+).zip")
           # tear down and recreate the directory where we will put the unpacked zip
           shutil.rmtree(tmp_repo_dir, ignore_errors=True)
           os.makedirs(tmp_repo_dir)
           # look in a directory for zipfiles
           zipfiles = os.listdir(zipfile_dir)
           for zipfile in zipfiles:
               filename_match = repo_commit_regex.search(zipfile)
               if not filename_match:
                   print("Badly named zipfile! {}".format(zipfile))
                   continue
               repo_name, commit_hash, branch = filename_match.groups()

               # unzip
               try:
                   zipfile_path = os.path.join(zipfile_dir, zipfile)
                   with ZipFile(zipfile_path, 'r') as zip_obj:
                       zip_obj.extractall(path=tmp_repo_dir)
                   # we should have made a new directory - find its name
                   unpacked_zips = os.listdir(tmp_repo_dir)
                   # should be one and only one directory in here
                   if len(unpacked_zips) != 1:
                       raise RuntimeError("Unexpected number of items in unpacked zip directory {}: {}".format(tmp_repo_dir, unpacked_zips))
                   unpacked_location = os.path.join(tmp_repo_dir, unpacked_zips[0])
                   output_list.append((repo_name, commit_hash, branch, unpacked_location))
               except(BadZipFile):
                   print("Bad zipfile: {}".format(zipfile))
                   continue
           return output_list


       def get_gitlab_config():
           """
           Return a dictionary containing the base URL for the gitlab API,
           the API token, the IP address, and the headers to go in any request
           """
           home = str(Path.home())

           with open(f"{home}/.secrets/gitlab-external-ip-address", "r") as f:
               ip = f.readlines()[0].strip()
           with open(f"{home}/.secrets/gitlab-external-api-token", "r") as f:
               token = f.readlines()[0].strip()

           api_url = f"http://{ip}/api/v4/"
           headers = {"Authorization": "Bearer " + token}

           return {"api_url": api_url,
                   "api_token": token,
                   "ip": ip,
                   "headers": headers}


       def get_group_namespace_ids(gitlab_url, gitlab_token,
                                   groups=["approval","unapproved"]):
           """
           Find the namespace_id corresponding to the groups we're interested in,
           e.g. 'approval' and 'unapproved'.

           Parameters
           ==========
           gitlab_url: str, base URL for the API
           gitlab_token: str, API token for Gitlab
           groups: list of string, the group names to look for.

           Returns
           =======
           namespace_id_dict: dict, format {<group_name:str>: <namespace_id:int>}

           """
           namespaces_url = "{}/namespaces/".format(gitlab_url)
           response = requests.get(namespaces_url,
                                   headers = {"Authorization": "Bearer "+gitlab_token})
           if response.status_code != 200:
               raise RuntimeError("Bad request: {} {}"\
                                  .format(response.status_code, response.content))
           gitlab_namespaces = response.json()
           namespace_id_dict = {}
           for namespace in gitlab_namespaces:
               if namespace["kind"] == "group" and namespace["name"] in groups:
                   namespace_id_dict[namespace["name"]] = namespace["id"]
           return namespace_id_dict


       def get_gitlab_project_list(gitlab_url, gitlab_token):
           """
           Get the list of Projects.

           Parameters
           ==========
           namespace_id: int, ID of the group ("unapproved" or "approval")
           gitlab_url: str, base URL for the API
           gitlab_token: str, API token.

           Returns
           =======
           gitlab_projects: list of dictionaries.
           """

           # list currently existing projects on Gitlab
           projects_url = "{}/projects/".format(gitlab_url)
           response = requests.get(projects_url,
                                   headers = {"Authorization": "Bearer "+gitlab_token},
                                   params = {"owned": True, "simple": True})

           if response.status_code != 200:
               raise RuntimeError("Bad request: {} {}"\
                                  .format(response.status_code, response.content))
           gitlab_projects = response.json()
           return gitlab_projects


       def check_if_project_exists(repo_name, namespace_id, gitlab_url, gitlab_token):
           """
           Get a list of projects from the API - check if namespace_id (i.e. group)
           and name match.

           Parameters
           ==========
           repo_name: str, name of our repository/project
           namespace_id: int, id of our group ("unapproved" or "approval")
           gitlab_url: str, base URL of Gitlab API
           gitlab_token: str, API key for Gitlab API.

           Returns
           =======
           bool, True if project exists, False otherwise.
           """
           projects = get_gitlab_project_list(gitlab_url, gitlab_token)
           for project in projects:
               if project["name"] == repo_name and \
                  project["namespace"]["id"] == namespace_id:
                   return True
           return False


       def get_project_info(repo_name, namespace_id, gitlab_url, gitlab_token):
           """
           Check if project exists, and if so get its ID.  Otherwise, create
           it and return the ID.

           Parameters
           ==========
           repo_name: str, name of our repository/project
           namespace_id: int, id of our group ("unapproved" or "approval")
           gitlab_url: str, base URL of Gitlab API
           gitlab_token: str, API key for Gitlab API.

           Returns
           =======
           project_info: dict, containing info from the projects API endpoint
           """
           already_exists = check_if_project_exists(repo_name,
                                                    namespace_id,
                                                    gitlab_url,
                                                    gitlab_token)
           if already_exists:
               projects = get_gitlab_project_list(gitlab_url, gitlab_token)
               for project_info in projects:
                   if project_info["name"] == repo_name and \
                      project_info["namespace"]["id"] == namespace_id:
                       return project_info
           else:
               project_info = create_project(repo_name,
                                             namespace_id,
                                             gitlab_url,
                                             gitlab_token)
               return project_info


       def get_project_remote_url(repo_name, namespace_id,
                                 gitlab_url, gitlab_token):
           """
           Given the name of a repository and  namespace_id (i.e. group,
           "unapproved" or "approval"), either return the remote URL for project
           matching the repo name, or create it if it doesn't exist already,
           and again return the remote URL.

           Parameters
           ==========
           repo_name: str, name of the repository/project we're looking for.
           namespace_id: int, the ID of the group ("unapproved" or "approval")
           gitlab_url: str, base URL of the API
           gitlab_token: str, API key

           Returns
           =======
           gitlab_project_url: str, the URL to be set as the "remote".
           """
           project_info = get_project_info(repo_name, namespace_id,
                                           gitlab_url, gitlab_token)

           return project_info["ssh_url_to_repo"]


       def get_project_id(repo_name, namespace_id,
                                 gitlab_url, gitlab_token):
           """
           Given the name of a repository and  namespace_id (i.e. group,
           "unapproved" or "approval"), either return the id of project
           matching the repo name, or create it if it doesn't exist already,
           and again return the id.

           Parameters
           ==========
           repo_name: str, name of the repository/project we're looking for.
           namespace_id: int, the ID of the group ("unapproved" or "approval")
           gitlab_url: str, base URL of the API
           gitlab_token: str, API key

           Returns
           =======
           gitlab_project_url: str, the URL to be set as the "remote".
           """
           project_info = get_project_info(repo_name, namespace_id,
                                           gitlab_url, gitlab_token)

           return project_info["id"]


       def create_project(repo_name, namespace_id, gitlab_url, gitlab_token):
           """
           Create empty project on gitlab, and return the corresponding remote URL.

           Parameters
           ==========
           repo_name: str, name of the repository/project
           namespace_id: int, ID of the group ("unapproved" or "approved")
           gitlab_url: str, base URL of the API
           gitlab_token: str, API token.

           Returns
           =======
           gitlab_project_info: dict, containing among other things, the name and
                               the remote URL for the project.
           """
           projects_url = "{}projects/".format(gitlab_url)
           response = requests.post(projects_url,
                                    headers = {"Authorization": "Bearer "+gitlab_token},
                                    data = {"name": repo_name,
                                            "visibility": "public",
                                            "namespace_id": namespace_id}
           )
           assert(response.json()["name"] == repo_name)
           project_info = response.json()
           print("Created project {} in namespace {}, project_id {}".\
                 format(repo_name, namespace_id, project_info["id"]))
           return project_info


       def check_if_branch_exists(branch_name,
                                  project_id,
                                  gitlab_url,
                                  gitlab_token):
           """
           See if a branch with name branch_name already exists on this Project

           Parameters
           ==========
           branch_name: str, name of branch to look for
           project_id: int, id of the project, obtained from projects API endpoint
           gitlab_url: base URL of the Gitlab API
           gitlab_token: API token for the Gitlab API

           Returns
           =======
           branch_exists: bool, True if branch exists, False if not.
           """
           branches_url = "{}/projects/{}/repository/branches".\
               format(gitlab_url, project_id)
           response = requests.get(branches_url,
                                   headers={"Authorization": "Bearer "+gitlab_token})
           if response.status_code != 200:
               raise RuntimeError("Unable to check for branch {} on project {}: {}".\
                                  format(branch_name, project_id, r.content))
           branches = response.json()
           for branch_info in branches:
               if branch_info["name"] == branch_name:
                   return True
           return False



       def create_branch(branch_name,
                         project_id,
                         gitlab_url,
                         gitlab_token,
                         reference_branch="master"):
           """
           Create a new branch on an existing project.  By default, use 'master'
           as the reference branch from which to create the new one.

           Parameters
           ==========
           branch_name: str, the desired name of the new branch
           project_id: int, the ID of the project, which is the "id" value in
                        the dictionary of project information returned when
                        creating a new project or listing existing ones.
           gitlab_url: str, the base URL for the Gitlab API
           gitlab_token: str, the Gitlab API token

           Returns
           =======
           branch_info: dict, info about the branch from API endpoint
           """
           # assume branch doesn't already exist - create it!
           branch_url = "{}/projects/{}/repository/branches".format(gitlab_url, project_id)
           response = requests.post(branch_url,
                                    headers = {"Authorization": "Bearer "+gitlab_token},
                                    data = {"branch": branch_name, "ref": reference_branch})
           if response.status_code != 201:
               raise RuntimeError("Problem creating branch {}: {}".format(branch_name,
                                                                          response.content))
           branch_info = response.json()
           assert branch_info["name"] == branch_name
           return branch_info


       def check_if_merge_request_exists(repo_name,
                                         source_project_id,
                                         source_branch,
                                         target_project_id,
                                         target_branch,
                                         gitlab_url, gitlab_token):
           """
           See if there is an existing merge request between the source and target
           project/branch combinations.

           Parameters
           ==========
           repo_name: str, name of the repository
           source_project_id: int, project_id for the unapproved project, obtainable
                                as the "ID" field of the json returned from the
                                projects API endpoint.
           source_branch: str, name of the branch on source project, will typically
                             be the commit_hash from the original repo.
           target_project_id: int, project_id for the "approval" group's project.
           target_branch: str, name of branch on target project, will typically
                             be the desired branch name.
           gitlab_url: str, base URL for the Gitlab API
           gitlab_token: str, API token for the Gitlab API.

           Returns
           =======
           bool, True if merge request already exists, False otherwise
           """
           mr_url = "{}/projects/{}/merge_requests".format(gitlab_url, source_project_id)
           response = requests.get(mr_url,
                                   headers = {"Authorization": "Bearer "+gitlab_token})
           if response.status_code != 200:
               raise RuntimeError("Request to check existence of MR failed: {} {}".\
                                  format(response.status_code, response.content))
           for mr in response.json():
               if mr["source_branch"] == source_branch and \
                  mr["target_branch"] == target_branch:
                   print("Merge request {} -> {} already exists".\
                         format(source_branch, target_branch))
                   return True
           return False


       def create_merge_request(repo_name,
                                source_project_id,
                                source_branch,
                                target_project_id,
                                target_branch,
                                gitlab_url, gitlab_token):

           """
           Create a new MR, e.g. from the branch <commit_hash> in the "unapproved"
           group's project, to the branch <desired_branch_name> in the "approval"
           group's project.

           Parameters
           ==========
           repo_name: str, name of the repository
           source_project_id: int, project_id for the unapproved project, obtainable
                                as the "ID" field of the json returned from the
                                projects API endpoint.
           source_branch: str, name of the branch on source project, will typically
                             be the commit_hash from the original repo.
           target_project_id: int, project_id for the "approval" group's project.
           target_branch: str, name of branch on target project, will typically
                             be the desired branch name.
           gitlab_url: str, base URL for the Gitlab API
           gitlab_token: str, API token for the Gitlab API.

           Returns
           =======
           mr_info: dict, the response from the API upon creating the Merge Request
           """
           # first need to create a forked-from relationship between the projects
           fork_url = "{}/projects/{}/fork/{}".format(gitlab_url,
                                                      source_project_id,
                                                      target_project_id)
           response = requests.post(fork_url,
                                    headers = {"Authorization": "Bearer "+gitlab_token})
           # status code 201 if fork relationship created, or 409 if already there
           if (response.status_code != 201) and (response.status_code != 409):
               raise RuntimeError("Unable to create fork relationship: {} {}".\
                                  format(response.status_code, response.content))

           mr_url = "{}/projects/{}/merge_requests".format(gitlab_url, source_project_id)
           title = "{}: {} to {}".format(repo_name, source_branch, target_branch)
           response = requests.post(mr_url,
                                    headers = {"Authorization": "Bearer "+gitlab_token},
                                    data = {"source_branch": source_branch,
                                            "target_branch": target_branch,
                                            "target_project_id": target_project_id,
                                            "title": title})
           if response.status_code != 201:
               raise RuntimeError("Problem creating Merge Request {} {} {}: {}"\
                                  .format(repo_name, source_branch,target_branch,
                                          response.content))
           mr_info = response.json()
           return mr_info





       def push_to_remote(path_to_unzipped_repo, commit_hash, remote_url):
           """
           Run shell commands to convert the unzipped directory containing the
           repository contents into a git repo, then commit it to a branch named
           as the commit_hash.

           Parameters
           ==========
           path_to_unzipped_repo: str, the full directory path to the unzipped repo
           commit_hash: str, original commit hash from the external git repo, will
                         be used as the name of the branch to push to
           remote_url: str, the URL for this project on gitlab-external to be added
                         as a "remote".
           """
           subprocess.run(["git","init"], cwd=path_to_unzipped_repo, check=True)
           # Create a branch named after the original commit hash
           subprocess.run(["git","checkout","-b",commit_hash],
                          cwd=path_to_unzipped_repo, check=True)
           # Commit everything to this branch, also putting commit hash into message
           subprocess.run(["git","add","."], cwd=path_to_unzipped_repo, check=True)
           subprocess.run(["git","commit","-m",commit_hash],
                          cwd=path_to_unzipped_repo, check=True)
           # add the remote_url as a remote called 'gitlab-external'
           subprocess.run(["git","remote","add","gitlab-external",remote_url],
                           cwd=path_to_unzipped_repo, check=True)
           # Push to gitlab external
           subprocess.run(["git","push","--force","--all","gitlab-external"],
                          cwd=path_to_unzipped_repo, check=True)


       def create_and_push_unapproved_project(repo_name,
                                              namespace_id,
                                              gitlab_url,
                                              gitlab_token,
                                              path_to_unzipped_repo,
                                              commit_hash):
           """
           We have unzipped a zipfile, and put the contents (i.e. the code we want
           to push) in path_to_unzipped_project.
           Now we create the project in the "unapproved" group on Gitlab, and push
           to it.

           Parameters
           ==========
           repo_name: str, name of our repository/project
           gitlab_url: str, the base URL of Gitlab API
           gitlab_token: str, API token for Gitlab API
           path_to_unzipped_repo: str, full directory path to code we want to commit
           commit_hash: str, the commit hash from the original repo, to be used as
                           the name of the branch we'll push to

           Returns
           =======
           project_id: int, ID of the project as returned by projects API endpoint
           """
           # Get project ID - project will be created if it didn't already exist
           project_id = get_project_id(repo_name, namespace_id, gitlab_url, gitlab_token)
           assert project_id
           # see if branch already exists with name=commit_hash
           branch_exists = check_if_branch_exists(commit_hash,
                                                  project_id,
                                                  gitlab_url,
                                                  gitlab_token)
           if branch_exists:
               print("Branch {} already exists".format(commit_hash))
               # already exists - do nothing
               return project_id
           # otherwise we need to commit code to it and push
           remote_url = get_project_remote_url(repo_name, namespace_id,
                                               gitlab_url, gitlab_token)
           print("remote URL for {} is {}".format(repo_name, remote_url))

           push_to_remote(path_to_unzipped_repo, commit_hash, remote_url)
           # Return the project_id, to use in merge request
           return project_id


       def create_approved_project_branch(repo_name,
                                          branch_name,
                                          namespace_id,
                                          gitlab_url,
                                          gitlab_token):
           """
           Create a new branch (and a new project if it doesn't already exist)
           owned by the "approval" group.  This will be the target for the merge
           request.

           Parameters
           ==========
           repo_name: str, repository name
           gitlab_url: str, base URL for Gitlab API
           gitlab_token: str, API token for Gitlab API
           branch_name: str, the desired branch name.

           Returns
           =======
           project_id: int, the "ID" field in the info from projects API endpoint
           """
           # get the project ID - project will be created if it doesn't already exist
           project_id = get_project_id(repo_name, namespace_id, gitlab_url, gitlab_token)
           assert project_id

           # create the branch if it doesn't already exist
           branch_exists = check_if_branch_exists(branch_name,
                                                  project_id,
                                                  gitlab_url,
                                                  gitlab_token)
           if not branch_exists:
               branch_info = create_branch(branch_name,
                                           project_id,
                                           gitlab_url,
                                           gitlab_token)
               assert branch_info["name"] == branch_name
           # return the ID of this project so we can use it in merge request
           return project_id


       def main():
           # create a directory to unpack the zipfiles into
           TMP_REPO_DIR = "/tmp/repos"
           os.makedirs(TMP_REPO_DIR, exist_ok=True)
           # get the gitlab config
           config = get_gitlab_config()
           ZIPFILE_DIR = "/zfiles"

           # unzip the zipfiles, and retrieve a list of tuples describing
           # (repo_name, commit_hash, desired_branch, unzipped_location)
           unzipped_repos = unzip_zipfiles(ZIPFILE_DIR, TMP_REPO_DIR)

           # get the namespace_ids of our "approval" and "unapproved" groups
           GROUPS = ["unapproved","approval"]
           namespace_ids = get_group_namespace_ids(config["api_url"],
                                                   config["api_token"],
                                                   GROUPS)

           # loop over all our newly unzipped repositories
           for repo in unzipped_repos:
               # unpack tuple
               repo_name, commit_hash, branch_name, location = repo
               print("Unpacked {} {} {}".format(repo_name, commit_hash, branch_name))
               src_project_id = create_and_push_unapproved_project(repo_name,
                                                                   namespace_ids[GROUPS[0]],
                                                                   config["api_url"],
                                                                   config["api_token"],
                                                                   location,
                                                                   commit_hash)
               print("Created project {}/{} branch {}".\
                     format(GROUPS[0],repo_name, commit_hash))

               # create project and branch on approved repo
               target_project_id = create_approved_project_branch(repo_name,
                                                                  branch_name,
                                                                  namespace_ids[GROUPS[1]],
                                                                  config["api_url"],
                                                                  config["api_token"])
               print("Created project {}/{} branch {}".\
                     format(GROUPS[1],repo_name, branch_name))

               mr_exists = check_if_merge_request_exists(repo_name,
                                                         src_project_id,
                                                         commit_hash,
                                                         target_project_id,
                                                         branch_name,
                                                         config["api_url"],
                                                         config["api_token"])
               if mr_exists:
                   print("Merge request {} -> {} already exists. skipping".\
                         format(commit_hash, branch_name))
               else:
                   # create merge request
                   create_merge_request(repo_name,
                                        src_project_id,
                                        commit_hash,
                                        target_project_id,
                                        branch_name,
                                        config["api_url"],
                                    config["api_token"])
                   print("Created merge request {} -> {}".\
                         format(commit_hash, branch_name))

       if __name__ == "__main__":
           main()

  # Script for monitoring and accepting approval merge requests
  - path: "/home/<sre-admin-username>/check_merge_requests.py"
    permissions: "0755"
    content: |
      import requests
      import subprocess
      from urllib.parse import quote as url_quote
      from pathlib import Path
      import logging
      from logging.handlers import RotatingFileHandler

      logger = logging.getLogger("merge_requests_logger")
      logger.setLevel(logging.INFO)
      formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")
      f_handler = RotatingFileHandler(
          "check_merge_requests.log", maxBytes=5 * 1024 * 1024, backupCount=10
      )
      f_handler.setFormatter(formatter)
      c_handler = logging.StreamHandler()
      c_handler.setFormatter(formatter)
      logger.addHandler(f_handler)
      logger.addHandler(c_handler)

      global HOME
      global GL_INTERNAL_IP
      global GL_INTERNAL_TOKEN
      global GL_INTERNAL_AUTH_HEADER

      HOME = str(Path.home())

      with open(f"{HOME}/.secrets/gitlab-internal-ip-address", "r") as f:
          GL_INTERNAL_IP = f.readlines()[0].strip()

      GL_INTERNAL_URL = "http://" + GL_INTERNAL_IP + "/api/v4"

      with open(f"{HOME}/.secrets/gitlab-internal-api-token", "r") as f:
          GL_INTERNAL_TOKEN = f.readlines()[0].strip()

      GL_INTERNAL_AUTH_HEADER = {"Authorization": "Bearer " + GL_INTERNAL_TOKEN}


      def internal_project_exists(repo_name):
          """Given a string (the name of a repo - not a URL), returns a pair
          (exists, url):
          - exists: boolean - does repo_name exist on GITLAB-INTERNAL?
          - url: str - the ssh url to the repo (when 'exists' is true)
          """

          # build url-encoded repo_name
          repo_path_encoded = url_quote("ingress/" + repo_name, safe='')

          # Does repo_name exist on GITLAB-INTERNAL?
          response = requests.get(GL_INTERNAL_URL + '/projects/' + repo_path_encoded,
                                  headers=GL_INTERNAL_AUTH_HEADER)

          if response.status_code == 404:
              return (False, "")
          elif response.status_code == 200:
              return (True, response.json()["ssh_url_to_repo"])
          else:
              # Not using `response.raise_for_status()`, since we also want
              # to raise an exception on unexpected "successful" responses
              # (not 200)
              raise requests.HTTPError("Unexpected response: " + response.reason
                                       + ", content: " + response.text)


      def internal_update_repo(gh_url, repo_name):
          """Takes a GitHub URL, `gh_url`, which should be the URL to the
          "APPROVED" repo, clones it and pushes all branches to the repo
          `repo_name` owned by 'ingress' on GITLAB-INTERNAL, creating it
          there first if it doesn't exist.
          """
          # clone the repo from gh_url (on GITLAB-EXTERNAL), removing any of
          # the same name first (simpler than checking if it exists, has the
          # same remote and pulling)
          subprocess.run(["rm", "-rf", repo_name], check=True)
          subprocess.run(["git", "clone", gh_url, repo_name], check=True)

          project_exists, gl_internal_repo_url = internal_project_exists(repo_name)

          # create the project if it doesn't exist
          if not project_exists:
              print("Creating: " + repo_name)
              response = requests.post(GL_INTERNAL_URL + '/projects',
                                       headers=GL_INTERNAL_AUTH_HEADER,
                                       data={"name": repo_name,
                                             "visibility": "public"})
              response.raise_for_status()
              assert(response.json()["path_with_namespace"] == "ingress/" + repo_name)

              gl_internal_repo_url = response.json()["ssh_url_to_repo"]

          # Set the remote
          subprocess.run(["git", "remote", "add", "gitlab-internal",
                          gl_internal_repo_url], cwd=repo_name, check=True)

          # Force push current contents of all branches
          subprocess.run(["git", "push", "--force", "--all",
                          "gitlab-internal"], cwd=repo_name, check=True)


      def get_request(endpoint, headers, params=None):
          r = requests.get(endpoint, headers=headers, params=params)
          if r.ok:
              return r.json()
          else:
              raise ValueError(
                  f"Request failed: URL {endpoint}, CODE {r.status_code}, CONTENT {r.content}"
              )


      def put_request(endpoint, headers, params=None):
          r = requests.put(endpoint, headers=headers, params=params)
          if r.ok:
              return r.json()
          else:
              raise ValueError(
                  f"Request failed: URL {endpoint}, CODE {r.status_code}, CONTENT {r.content}"
              )


      def get_gitlab_config(server="external"):
          home = str(Path.home())

          if server == "external":
              with open(f"{home}/.secrets/gitlab-external-ip-address", "r") as f:
                 ip = f.readlines()[0].strip()
              with open(f"{home}/.secrets/gitlab-external-api-token", "r") as f:
                 token = f.readlines()[0].strip()
          elif server == "internal":
              with open(f"{home}/.secrets/gitlab-internal-ip-address", "r") as f:
                  ip = f.readlines()[0].strip()
              with open(f"{home}/.secrets/gitlab-internal-api-token", "r") as f:
                  token = f.readlines()[0].strip()
          else:
              raise ValueError("Server must be external or internal")

          api_url = f"http://{ip}/api/v4/"
          headers = {"Authorization": "Bearer " + token}

          return {"api_url": api_url, "api_token": token, "ip": ip, "headers": headers}


      def get_group_id(group_name, config):
          endpoint = config["api_url"] + "groups"
          response = get_request(endpoint, headers=config["headers"])
          for group in response:
              if group["name"] == group_name:
                  return group["id"]
          raise ValueError(f"{group_name} not found in groups.")


      def get_project(project_id, config):
          endpoint = config["api_url"] + f"projects/{project_id}"
          project = get_request(endpoint, headers=config["headers"])
          return project


      def get_merge_requests_for_approval(config):
          group = get_group_id("approval", config)
          endpoint = config["api_url"] + f"/groups/{group}/merge_requests"
          response = get_request(
              endpoint, headers=config["headers"], params={"state": "opened"}
          )
          return response


      def count_unresolved_mr_discussions(mr, config):
          if mr["user_notes_count"] == 0:
              return 0
          project_id = mr["project_id"]
          mr_iid = mr["iid"]
          endpoint = (
              config["api_url"] + f"projects/{project_id}/merge_requests/{mr_iid}/discussions"
          )
          discussions = get_request(endpoint, headers=config["headers"])
          if len(discussions) == 0:
              return 0
          else:
              n_unresolved = 0
              for d in discussions:
                  for n in d["notes"]:
                      if n["resolvable"] is True and n["resolved"] is False:
                          n_unresolved += 1
              return n_unresolved


      def accept_merge_request(mr, config):
          project_id = mr["project_id"]
          mr_iid = mr["iid"]
          endpoint = (
              config["api_url"] + f"projects/{project_id}/merge_requests/{mr_iid}/merge"
          )
          return put_request(endpoint, headers=config["headers"])


      def check_merge_requests():
          logger.info(f"STARTING RUN")

          try:
              config = get_gitlab_config(server="external")
          except Exception as e:
              logger.critical(f"Failed to load gitlab secrets: {e}")
              return

          logger.info("Getting open merge requests for approval")
          try:
              merge_requests = get_merge_requests_for_approval(config)
          except Exception as e:
              logger.critical(f"Failed to get merge requests: {e}")
              return
          logger.info(f"Found {len(merge_requests)} open merge requests")

          for i, mr in enumerate(merge_requests):
              logger.info("-" * 20)
              logger.info(f"Merge request {i+1} out of {len(merge_requests)}")
              try:
                  source_project = get_project(mr["source_project_id"], config)
                  logger.info(f"Source Project: {source_project['name_with_namespace']}")
                  logger.info(f"Source Branch: {mr['source_branch']}")
                  target_project = get_project(mr["project_id"], config)
                  logger.info(f"Target Project: {target_project['name_with_namespace']}")
                  logger.info(f"Target Branch: {mr['target_branch']}")
                  logger.info(f"Commit SHA: {mr['sha']}")
                  logger.info(f"Created At: {mr['created_at']}")
                  status = mr["merge_status"]
                  logger.info(f"Merge Status: {status}")
                  wip = mr["work_in_progress"]
                  logger.info(f"Work in Progress: {wip}")
                  unresolved = count_unresolved_mr_discussions(mr, config)
                  logger.info(f"Unresolved Discussions: {unresolved}")
                  upvotes = mr["upvotes"]
                  logger.info(f"Upvotes: {upvotes}")
                  downvotes = mr["downvotes"]
                  logger.info(f"Downvotes: {downvotes}")
              except Exception as e:
                  logger.error(f"Failed to extract merge request details: {e}")
                  continue
              if (
                  status == "can_be_merged"
                  and wip is False
                  and unresolved == 0
                  and upvotes >= 2
                  and downvotes == 0
              ):
                  logger.info("Merge request has been approved. Proceeding with merge.")
                  try:
                      result = accept_merge_request(mr, config)
                  except Exception as e:
                      logger.error(f"Merge failed! {e}")
                      continue
                  if result["state"] == "merged":
                      logger.info(f"Merge successful! Merge SHA {result['merge_commit_sha']}")
                      try:
                          with open("accepted_merge_requests.log", "a") as f:
                              f.write(
                                  f"{result['merged_at']}, {source_project['name_with_namespace']}, {mr['source_branch']}, {mr['sha']}, {target_project['name_with_namespace']}, {mr['target_branch']}, {result['merge_commit_sha']}\n"
                              )
                      except Exception as e:
                          logger.error(f"Failed to log accepted merge request: {e}")
                      try:
                          internal_update_repo(
                              target_project["ssh_url_to_repo"],
                              target_project["name"]
                          )
                      except Exception as e:
                          logger.error(f"Failed to push to internal: {e}")
                  else:
                      logger.error(f"Merge failed! Merge status is {result['state']}")
              else:
                  logger.info("Merge request has not been approved. Skipping.")
          logger.info(f"RUN FINISHED")
          logger.info("=" * 30)


      if __name__ == "__main__":
          check_merge_requests()

runcmd:
  # --------------------------------
  # SETUP GITLAB EXTERNAL SERVER
  # --------------------------------
  # Configure server
  - echo "Configuring gitlab external server"
  - echo "<gitlab-external-ip> <gitlab-external-hostname> <gitlab-external-fqdn>" >> /etc/hosts
  - echo "Europe/London" > /etc/timezone
  - dpkg-reconfigure -f noninteractive tzdata
  # Set up the data disk
  - echo "Setting up data disk..."
  - parted /dev/sdc mklabel gpt
  - parted /dev/sdc mkpart primary ext4 0% 100%
  - parted /dev/sdc print
  - sleep 5
  - mkfs -t ext4 /dev/sdc1
  - mkdir -p /datadrive
  - mount /dev/sdc1 /datadrive
  - UUID=$(blkid | grep "/dev/sdc1" | cut -d'"' -f2)
  - sed "s|UUID|UUID=$UUID\t/datadrive\text4\tdefaults,nofail\t1\t2\nUUID|" /etc/fstab > fstab.tmp
  - mv fstab.tmp /etc/fstab
  - mkdir -p /datadrive/gitlab-data
  # Enable custom GitLab settings and run an initial configuration
  - echo "Running initial configuration"
  - gitlab-ctl reconfigure
  # Set root password and don't prompt for it to be reset when web app first loaded
  - |
    echo "user = User.find_by(username: 'root');user.password=user.password_confirmation='<gitlab-external-root-password>';user.password_automatically_set=false;user.save!;exit;" | gitlab-rails console -e production
  # Turn off user account creation
  - |
    gitlab-rails runner "ApplicationSetting.last.update_attributes(signup_enabled: false)"
  # Restrict login to SHM domain (must be done AFTER GitLab update)
  - |
    gitlab-rails runner "ApplicationSetting.last.update_attributes(domain_whitelist: ['<gitlab-external-login-domain>'])"
  # Create user for ingressing external git repos
  - |
    echo "user = User.create(:username => '<gitlab-external-username>', :password => '<gitlab-external-password>', :password_confirmation => '<gitlab-external-password>', :email =>'<gitlab-external-username>@<gitlab-external-login-domain>', :skip_confirmation => true, :name => '<gitlab-external-username>');user.save!;exit;" | gitlab-rails console -e production
  # Create a API token for the ingress user created above
  - |
    echo "user = User.find_by(username: '<gitlab-external-username>');user.personal_access_tokens.create(name: 'apitoken', token_digest: Gitlab::CryptoHelper.sha256('<gitlab-external-api-token>'), impersonation: false, scopes: [:api]);exit;" | gitlab-rails console -e production
  # Reload GitLab configuration and restart GitLab
  - gitlab-ctl reconfigure
  - gitlab-ctl restart
  # --------------------------------
  # Create SSH key
  # --------------------------------
  - |
    mkdir -p /home/<sre-admin-username>/.ssh;
    ssh-keygen -t ed25519 -C 'gitlab' -N '' -f /home/<sre-admin-username>/.ssh/id_ed25519;
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/id_ed25519"
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/id_ed25519.pub"
  # --------------------------------
  # SETUP ACCESS TO GITLAB INTERNAL
  # --------------------------------
  - echo "Configuring access to gitlab internal"
  # Change ownership of secrets to <sre-admin-username>
  - |
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-api-token";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-ip-address";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-username";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-internal-user-email";
  # Create SSH key for gitlab internal access, add gitlab internal to known hosts
  - |
    key=$(cat /home/<sre-admin-username>/.ssh/id_ed25519.pub);
    curl --header 'Authorization: Bearer <gitlab-internal-api-token>' --header 'Content-Type:application/json' --data "{\"key\": \"$key\", \"title\": \"InternalAPIUser\"}" <gitlab-internal-ip>/api/v4/user/keys;
    ssh-keyscan -H <gitlab-internal-ip> >> /home/<sre-admin-username>/.ssh/known_hosts;
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/known_hosts"
  # --------------------------------
  # WAIT FOR GITLAB EXTERNAL HEALTH CHECK
  # --------------------------------
  - |
    attempt_counter=0
    max_attempts=60
    echo "Waiting for GitLab OK health check"
    until [ "$(curl -s localhost/-/health)" = "GitLab OK" ]
    do
      if [ ${attempt_counter} -eq ${max_attempts} ];then
        echo
        echo "FAILED: Max GitLab attempts reached. Exiting."
        exit 1
      fi
      printf "."
      attempt_counter=$((attempt_counter+1))
      sleep 10
    done
    echo
  # --------------------------------
  # SETUP ACCESS TO GITLAB EXTERNAL
  # --------------------------------
  - echo "Configuring access to gitlab external"
  # Change ownership of secrets to <sre-admin-username>
  - |
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-api-token";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-ip-address";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-username";
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.secrets/gitlab-external-user-email";
  # Create SSH key for gitlab external access, add gitlab external to known hosts
  - |
    key=$(cat /home/<sre-admin-username>/.ssh/id_ed25519.pub);
    curl --header 'Authorization: Bearer <gitlab-external-api-token>' --header 'Content-Type:application/json' --data "{\"key\": \"$key\", \"title\": \"ExternalAPIUser\"}" <gitlab-external-ip>/api/v4/user/keys;
    ssh-keyscan -H <gitlab-external-ip> >> /home/<sre-admin-username>/.ssh/known_hosts;
    chown <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>/.ssh/known_hosts"
  # Create groups for storing unapproved and approval repos
  - |
    curl --header "Authorization: Bearer <gitlab-external-api-token>" --data "name=approval&path=approval&visibility=public" <gitlab-external-ip>/api/v4/groups;
    curl --header "Authorization: Bearer <gitlab-external-api-token>" --data "name=unapproved&path=unapproved&visibility=public" <gitlab-external-ip>/api/v4/groups
  # --------------------------------
  # FINAL SETUP
  # --------------------------------
  - echo "Finishing setup"
  # Configure global git user to be gitlab internal user
  - |
    HOME=/home/<sre-admin-username> git config --global user.name '<gitlab-internal-username>';
    HOME=/home/<sre-admin-username> git config --global user.email '<gitlab-internal-username>@<gitlab-internal-login-domain>';
  # Give <sre-admin-username> ownership of their home directory
  - |
    chown -R <sre-admin-username>:<sre-admin-username> "/home/<sre-admin-username>";

# Shutdown so that we can tell when the job has finished by polling the VM state
power_state:
  mode: poweroff
  message: "Shutting down as a signal that setup is finished"
  timeout: 30
  condition: true
