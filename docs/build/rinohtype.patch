--- backend/pdf/cos.py	2021-11-12 15:57:28.000000000 +0000
+++ backend/pdf/cos.py	2021-11-12 16:05:49.000000000 +0000
@@ -1000,7 +1000,12 @@
         self.print(' def')

     def _value(self, value, number_of_bytes=2):
-        hex_str = HexString((value).to_bytes(number_of_bytes, byteorder='big'))
+        try:
+            hex_str = HexString((value).to_bytes(number_of_bytes, byteorder='big'))
+        except OverflowError:
+            # This is a hack to deal with 4-byte codepoints.
+            # A better method of specifying the expected byte size should be used here.
+            hex_str = HexString((value).to_bytes(2 * number_of_bytes, byteorder='big'))
         self.write(hex_str.bytes(None))

     def print(self, strng, end='\n'):
--- font/opentype/__init__.py	2021-11-12 15:57:28.000000000 +0000
+++ font/opentype/__init__.py	2021-11-12 16:04:58.000000000 +0000
@@ -84,8 +84,8 @@
         # TODO: properly handle encodings
         glyphs_by_char = {}
         cmap_tables = self['cmap']
-        for encoding in [UNICODE_20_BMP, WINDOWS_UNICODE_BMP, UNICODE_ISO,
-                         UNICODE_11, UNICODE_10, WINDOWS_SYMBOL]:
+        for encoding in [UNICODE_20_NONBMP, UNICODE_20_BMP, WINDOWS_UNICODE_BMP,
+                         UNICODE_ISO, UNICODE_11, UNICODE_10, WINDOWS_SYMBOL]:
             try:
                 for ordinal, index in cmap_tables[encoding].mapping.items():
                     glyphs_by_char[chr(ordinal)] = glyphs_by_code[index]
@@ -193,5 +193,6 @@
 UNICODE_11 = (0, 1)
 UNICODE_ISO = (0, 2)
 UNICODE_20_BMP = (0, 3)
+UNICODE_20_NONBMP = (0, 4)
 WINDOWS_UNICODE_BMP = (3, 1)
 WINDOWS_SYMBOL = (3, 0)
